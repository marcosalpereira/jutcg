package br.gov.esaf.sgc.view.correcao;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jboss.seam.ScopeType;
import org.jboss.seam.annotations.Factory;
import org.jboss.seam.annotations.In;
import org.jboss.seam.annotations.Name;
import org.jboss.seam.annotations.Scope;

import br.gov.esaf.sgc.facade.ValidarNotasFacade;
import br.gov.esaf.sgc.model.Concurso;
import br.gov.esaf.sgc.model.prova.Prova;
import br.gov.esaf.sgc.model.prova.ConteudoProva.TipoConteudoProva;
import br.gov.esaf.sgc.model.resultado.ResultadoProvaManual;
import br.gov.esaf.sgc.model.resultado.ResultadoProvaManual.VersaoResultadoProvaManual;
import br.gov.esaf.sgc.view.PaginacaoBean;
import br.gov.esaf.sgc.view.exception.GeracaoRelatorioException;
import br.gov.esaf.sgc.view.service.RelatorioService;
import br.gov.serpro.AbstractLazyList;
import br.gov.serpro.view.util.FileHelper;
import br.gov.serpro.view.util.MessageHelper;
import br.gov.serpro.view.util.FileHelper.TipoConteudoArquivo;

/**
 * Bean para o caso de uso validar notas de Resultado Manual.
 */
@Name("validarNotasBean")
@Scope(ScopeType.CONVERSATION)
public class ValidarNotasBean {

    /**
     * Mapeamento entre os tipos de prova de correcao manual e as paginas de
     * digitaca de resultado correspondentes.
     */
    private static final Map<TipoConteudoProva, String> PAGINAS_RESULTADO;
    static {
        final Map<TipoConteudoProva, String> map = new HashMap<TipoConteudoProva, String>();
        map.put(TipoConteudoProva.CONTEUDO_PROVA_SUBJETIVA,
            "validarNotas_questoes");
        map.put(TipoConteudoProva.CONTEUDO_PROVA_TITULOS,
            "validarNotas_titulos");
        map.put(TipoConteudoProva.CONTEUDO_PROVA_HABILITACAO,
            "validarNotas_habilitacao");
        PAGINAS_RESULTADO = Collections.unmodifiableMap(map);
    }

    /**
     * Lista de concursos.
     */
    private List<Concurso> concursos;

    /**
     * Concurso selecionado.
     */
    private Concurso concursoSelecionado;

    /**
     * Lista de provas.
     */
    private List<Prova> provas;

    /**
     * Prova selecionada.
     */
    private Prova provaSelecionada;

    /**
     * Lista de versões de nota.
     */
    private List<VersaoResultadoProvaManual> versoes;

    /**
     * Versão da nota selecionada.
     */
    private VersaoResultadoProvaManual versaoSelecionada;

    /**
     * Fachada Digitacao Resultado Nota Manual.
     */
    @In("validarNotasFacade")
    private transient ValidarNotasFacade facade;

    /**
     * {@link PaginacaoBean}.
     */
    @In
    private PaginacaoBean paginacaoBean;

    /**
     * {@link RelatorioService}.
     */
    @In
    private RelatorioService relatorioService;

    /**
     * Resultados pesquisados.
     */
    private List<ResultadoProvaManual> resultados;

    /**
     * Disponível somente caso: <li>o status dos resultados da versão
     * selecionada seja "Cadastrado" e; <li>a aplicação de prova da prova
     * selecionada possui relatório de fechamento de concurso com situação
     * "Fechada".
     */
    private boolean mostrarBotaoValidacao;

    /**
     * Disponível somente caso: <li>o status dos resultados da versão
     * selecionada seja "Validado" e; <li>nenhuma Lista de Resultado foi gerada
     * com a versão selecionada.
     */
    private boolean mostrarBotaoCancelarValidacao;

    void setPaginacaoBean(PaginacaoBean paginacaoBean) {
        this.paginacaoBean = paginacaoBean;
    }

    void setMostrarBotaoCancelarValidacao(boolean mostrarBotaoCancelarValidacao) {
        this.mostrarBotaoCancelarValidacao = mostrarBotaoCancelarValidacao;
    }

    void setMostrarBotaoValidacao(boolean mostrarBotaoValidacao) {
        this.mostrarBotaoValidacao = mostrarBotaoValidacao;
    }

    public List<Concurso> getConcursos() {
        return concursos;
    }

    public void setConcursos(List<Concurso> concursos) {
        this.concursos = concursos;
    }

    public Concurso getConcursoSelecionado() {
        return concursoSelecionado;
    }

    public void setConcursoSelecionado(Concurso concursoSelecionado) {
        this.concursoSelecionado = concursoSelecionado;
    }

    public List<Prova> getProvas() {
        return provas;
    }

    public void setProvas(List<Prova> provas) {
        this.provas = provas;
    }

    public Prova getProvaSelecionada() {
        return provaSelecionada;
    }

    public void setProvaSelecionada(Prova provaSelecionada) {
        this.provaSelecionada = provaSelecionada;
    }

    public List<VersaoResultadoProvaManual> getVersoes() {
        return versoes;
    }

    public void setVersoes(List<VersaoResultadoProvaManual> versoes) {
        this.versoes = versoes;
    }

    public VersaoResultadoProvaManual getVersaoSelecionada() {
        return versaoSelecionada;
    }

    public void setVersaoSelecionada(VersaoResultadoProvaManual versaoSelecionada) {
        this.versaoSelecionada = versaoSelecionada;
    }

    public ValidarNotasFacade getFacade() {
        return facade;
    }

    public void setFacade(ValidarNotasFacade facade) {
        this.facade = facade;
    }

    public List<ResultadoProvaManual> getResultados() {
        return resultados;
    }

    public void setResultados(List<ResultadoProvaManual> resultados) {
        this.resultados = resultados;
    }

    /**
     * Consultar os concursos.
     * @return lista de concurso
     */
    @Factory("validarNotasBean_concursos")
    public List<Concurso> consultarConcursos() {
        return facade.consultarConcursos();
    }

    /**
     * Chamado quando ocorre evento de mudança no concurso.
     */
    public void onChangeConcurso() {
        this.provas = facade.consultarProvas(this.concursoSelecionado);
        this.provaSelecionada = null;
        this.versoes = null;
        this.resultados = null;
    }

    /**
     * Chamado quando ocorre evento de mudança na prova.
     */
    public void onChangeProva() {
        this.versoes = facade.consultarVersoes(this.provaSelecionada);
        this.versaoSelecionada = null;
        this.resultados = null;
    }

    /**
     * Chamado quando ocorre evento de mudança na versao.
     */
    public void onChangeVersao() {
        this.resultados = null;
    }

    public boolean isMostrarBotaoValidacao() {
        return this.resultados != null && mostrarBotaoValidacao;
    }

    public boolean isMostrarBotaoCancelarValidacao() {
        return this.resultados != null && this.mostrarBotaoCancelarValidacao;
    }

    /**
     * Validar as notas manuais da versao selecionada.
     * <p>
     * Devem ter sido preenchidas todas as notas da prova selecionada para todos
     * os candidatos habilitados para a fase à qual pertence a prova
     * selecionada.
     * </p>
     * <p>
     * São considerados candidatos habilitados para a fase:
     * <li>Caso a fase à qual pertence a prova não possua fase predecessora:
     * todos os candidatos inscritos no concurso com o status da inscrição
     * "Confirmado" ou;
     * <li>Caso a fase à qual pertence a prova possua fase predecessora: todos
     * os candidatos habilitados na fase predecessora, conforme sua lista
     * definitiva.
     * </p>
     * <p>
     * Caso esta regra não seja atendida, deve ser emitida a mensagem:
     * "Existe Candidato sem nota cadastrada.". Deve ser exibida também a
     * relação dos candidatos que não possuem todas as notas cadastradas para a
     * versão selecionada, com as informações número de inscrição e nome do
     * candidato.
     * </p>
     *  
     */
    public void validarNotas() {
        if (!facade.todasAsNotasForamPreenchidas(this.provaSelecionada,
            this.versaoSelecionada)) {
            MessageHelper.addErrorMessage("validarNotasForm:prova",
                "page.validarNotas.msg.existeCandidatoSemNota");
            return;
        }

        facade2.validarNotas(this.provaSelecionada, this.versaoSelecionada);
        this.mostrarBotaoValidacao = false;
        this.mostrarBotaoCancelarValidacao = true;
    }

    /**
     * Cancelar a validacao das notas manuais da versao selecionada.
     */
    public void cancelarValidacaoNotas() {
        facade.cancelarValidacaoNotas(this.provaSelecionada, this.versaoSelecionada);
        this.mostrarBotaoValidacao = true;
        this.mostrarBotaoCancelarValidacao = false;
    }

    /**
     * Imprimir o resultado da pesquisa.
     * @throws GeracaoRelatorioException em caso de erro
     * @throws IOException em caso de erro
     */
    public void imprimir() throws GeracaoRelatorioException, IOException {
        byte[] relatorio = relatorioService.gerarRelatorioValidarNotas(resultados);
        FileHelper.enviarArquivo(TipoConteudoArquivo.PDF, relatorio, "validarNotas");
    }

    /**
     * Pesquisar candidatos habilitados para etapa/fase a qual pertence a prova,
     * observando todos os parâmetros informados.
     * @return pagina que mostra o resultado apropriado.
     */
    public String pesquisar() {
        this.resultados = new ResultadosLazyList(facade, paginacaoBean
            .getNumeroLinhasTabelaPadrao());
        this.mostrarBotaoValidacao = verificarSeMostraBotaoValidar();
        this.mostrarBotaoCancelarValidacao = verificarSeMostraBotaoCancelarValidacao();
        return PAGINAS_RESULTADO.get(this.provaSelecionada.getTipoConteudoProva());
    }

    /**
     * Lista dos resultados pesquisados sob demanda da paginacao do usuario.
     */
    class ResultadosLazyList extends AbstractLazyList<ResultadoProvaManual> {

        /**
         * {@link ValidarNotasFacade}.
         */
        private ValidarNotasFacade provedorDados;

        /**
         * Construtor.
         * @param quantidadeRegistrosPorVez quantidade de registros que pesquisa por vez
         * @param provedorDados provedor de dados
         */
        public ResultadosLazyList(ValidarNotasFacade provedorDados,
            int quantidadeRegistrosPorVez) {
            super(quantidadeRegistrosPorVez);
            this.provedorDados = provedorDados;
        }

        /** {@inheritDoc} */
        @Override
        protected List<ResultadoProvaManual> consultarRegistros(int posicaoInicial,
            int quantidadeRegistrosPorVez) {
            return provedorDados.pesquisarResultados(provaSelecionada, versaoSelecionada,
                posicaoInicial, quantidadeRegistrosPorVez);
        }

        /** {@inheritDoc} */
        @Override
        protected int contarQuantidadeTotalRegistros() {
            return facade.pesquisarResultadosContar(provaSelecionada, versaoSelecionada);
        }

    }

    /**
     * Verifica se é para mostrar o botao cancelar validacao.
     * @return <code>true</code> se: <li>o status dos resultados da versão
     *         selecionada seja "Validado" e; <li>nenhuma Lista de Resultado foi
     *         gerada com a versão selecionada.
     */
    boolean verificarSeMostraBotaoCancelarValidacao() {
        if (this.resultados == null || this.resultados.isEmpty()
            || !this.resultados.get(0).isValidado()) {
            return false;
        }

        if (facade.naoFoiGeradoListaResultado(this.provaSelecionada,
            this.versaoSelecionada)) {
            return true;
        }

        return false;
    }

    /**
     * Verifica se é para mostrar o botao validar.
     * @return <code>true</code> se: <li>o status dos resultados da versão
     *         selecionada seja "Cadastrado" e; <li>caso o tipo de prova
     *         selecionada seja distinto de Títulos, a aplicação de prova da
     *         mesma deve possuir relatório de fechamento de concurso com
     *         situação "Fechada".
     */
    boolean verificarSeMostraBotaoValidar() {
        if (this.resultados == null || this.resultados.isEmpty()
            || !this.resultados.get(0).isCadastrado()) {
            return false;
        }

        final boolean isProvaTitulos = this.provaSelecionada
            .getTipoConteudoProva() == TipoConteudoProva.CONTEUDO_PROVA_TITULOS;

        if (isProvaTitulos) {
            return true;
        }

        if (facade.existeRelatorioConcursoFechado(this.provaSelecionada
            .getAplicacaoProva())) {
            return true;
        }

        return false;

    }

}
