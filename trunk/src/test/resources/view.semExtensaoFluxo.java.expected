package br.gov.esaf.sgc.view.correcao;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.jboss.seam.ScopeType;
import org.jboss.seam.annotations.In;
import org.jboss.seam.annotations.Name;
import org.jboss.seam.annotations.Observer;
import org.jboss.seam.annotations.Scope;
import br.gov.esaf.sgc.facade.DigitacaoNotaManualFacade;
import br.gov.esaf.sgc.model.Inscricao;
import br.gov.esaf.sgc.model.UsuarioLogado;
import br.gov.esaf.sgc.model.prova.Prova;
import br.gov.esaf.sgc.model.resultado.ResultadoProvaManual.VersaoResultadoProvaManual;
import static org.easymock.EasyMock.*;
import org.junit.*;
import java.util.*;
import static org.junit.Assert.*;
import br.gov.esaf.sgc.view.JsfTestCase;

/**
 * Testes unitarios para a classe {@link DigitacaoNotaManualListarBean}.
 */
public class TestDigitacaoNotaManualListarBean extends JsfTestCase {

/**
 * Classe sendo testada {@link DigitacaoNotaManualListarBean}.
 */
private DigitacaoNotaManualListarBean digitacaoNotaManualListarBean;

/**
 * Cria o mock {@link DigitacaoNotaManualFacade} e seta na classe sendo testada.
 * @return o mock criado
 */
private DigitacaoNotaManualFacade criarMockDigitacaoNotaManualFacade() {
  DigitacaoNotaManualFacade mock = createStrictMock(DigitacaoNotaManualFacade.class);
  digitacaoNotaManualListarBean.setDigitacaoNotaManualFacade(mock);
  return mock;
}

/** {@inheritDoc} */
@Override
public void setUp() throws Exception {
  super.setUp();
  digitacaoNotaManualListarBean = new DigitacaoNotaManualListarBean();
}

/**
 * Teste para o metodo {@link DigitacaoNotaManualListarBean#pesquisar()}.
 * Descricao do Fluxo: 
 *     Entra: if (versaoSelecionada == VersaoResultadoProvaManual.PROVISORIA) {
 *     Entra: for (Inscricao inscricao : inscricoes) {.
 */
@Test
public void testPesquisarPath1() {
// variaveis usadas
final List<Inscricao> inscricoes = Arrays.asList(new Inscricao(1));
final Map<Inscricao, Boolean> inscricoesExcluiveis = newHashMap(new Inscricao(2), Boolean.FALSE);
final UsuarioLogado usuarioLogado = new Usuario(1);
final VersaoResultadoProvaManual versaoSelecionada = VersaoResultadoProvaManual.PROVISORIA;

// Configurando mock
DigitacaoNotaManualFacade digitacaoNotaManualFacade = criarMockDigitacaoNotaManualFacade();
expect(digitacaoNotaManualFacade.consultarInscricoes(usuarioLogado))
  .andReturn(inscricoes);
boolean bExcluivel = false;
expect(digitacaoNotaManualFacade.existeNotaProvisoriaStatusCadastrada(inscricao))
  .andReturn(bExcluivel);
replay(digitacaoNotaManualFacade);

// Configurando estado interno da classe sob teste
digitacaoNotaManualListarBean.setInscricoes(inscricoes);
digitacaoNotaManualListarBean.setInscricoesExcluiveis(inscricoesExcluiveis);
digitacaoNotaManualListarBean.setUsuarioLogado(usuarioLogado);
digitacaoNotaManualListarBean.setVersaoSelecionada(versaoSelecionada);

// invocar metodo sendo testado
digitacaoNotaManualListarBean.pesquisar();

// checar estados dos mocks
verify(digitacaoNotaManualFacade);

// verificacoes do resultado do metodo sendo testado
final List<Inscricao> getInscricoesExpected = <IDontKnowButYouDo>;
assertEquals(getInscricoesExpected, digitacaoNotaManualListarBean.getInscricoes());
final Map<Inscricao, Boolean> getInscricoesExcluiveisExpected = <IDontKnowButYouDo>;
assertEquals(getInscricoesExcluiveisExpected, digitacaoNotaManualListarBean.getInscricoesExcluiveis());
assertNull(digitacaoNotaManualListarBean.getNullAssignedField());
assertEquals(inscricoes.get(0) , digitacaoNotaManualListarBean.getNotNullAssignedField());
}

/**
 * Teste para o metodo {@link DigitacaoNotaManualListarBean#pesquisar()}.
 * Descricao do Fluxo: 
 *     Entra: if (versaoSelecionada == VersaoResultadoProvaManual.PROVISORIA) {
 * NAO Entra: for (Inscricao inscricao : inscricoes) {.
 */
@Test
public void testPesquisarPath2() {
// variaveis usadas
final List<Inscricao> inscricoes = Arrays.asList(new Inscricao(1));
final UsuarioLogado usuarioLogado = new Usuario(1);
final VersaoResultadoProvaManual versaoSelecionada = VersaoResultadoProvaManual.PROVISORIA;

// Configurando mock
DigitacaoNotaManualFacade digitacaoNotaManualFacade = criarMockDigitacaoNotaManualFacade();
expect(digitacaoNotaManualFacade.consultarInscricoes(usuarioLogado))
  .andReturn(inscricoes);
replay(digitacaoNotaManualFacade);

// Configurando estado interno da classe sob teste
digitacaoNotaManualListarBean.setInscricoes(inscricoes);
digitacaoNotaManualListarBean.setUsuarioLogado(usuarioLogado);
digitacaoNotaManualListarBean.setVersaoSelecionada(versaoSelecionada);

// invocar metodo sendo testado
digitacaoNotaManualListarBean.pesquisar();

// checar estados dos mocks
verify(digitacaoNotaManualFacade);

// verificacoes do resultado do metodo sendo testado
final List<Inscricao> getInscricoesExpected = <IDontKnowButYouDo>;
assertEquals(getInscricoesExpected, digitacaoNotaManualListarBean.getInscricoes());
final Map<Inscricao, Boolean> getInscricoesExcluiveisExpected = <IDontKnowButYouDo>;
assertEquals(getInscricoesExcluiveisExpected, digitacaoNotaManualListarBean.getInscricoesExcluiveis());
assertNull(digitacaoNotaManualListarBean.getNullAssignedField());
assertEquals(inscricoes.get(0) , digitacaoNotaManualListarBean.getNotNullAssignedField());
}

/**
 * Teste para o metodo {@link DigitacaoNotaManualListarBean#pesquisar()}.
 * Descricao do Fluxo: 
 * NAO Entra: if (versaoSelecionada == VersaoResultadoProvaManual.PROVISORIA) {.
 */
@Test
public void testPesquisarPath3() {
// variaveis usadas
final VersaoResultadoProvaManual versaoSelecionada = VersaoResultadoProvaManual.PROVISORIA;

// Configurando estado interno da classe sob teste
digitacaoNotaManualListarBean.setVersaoSelecionada(versaoSelecionada);

// invocar metodo sendo testado
digitacaoNotaManualListarBean.pesquisar();

// verificacoes do resultado do metodo sendo testado
final Map<Inscricao, Boolean> getInscricoesExcluiveisExpected = <IDontKnowButYouDo>;
assertEquals(getInscricoesExcluiveisExpected, digitacaoNotaManualListarBean.getInscricoesExcluiveis());
}
/**
 * Criar um HashMap e colocar a chave/valor passados nele.
 *  @param <K> tipo base da chave
 *  @param <V> tipo base do valor
 *  @param key chave
 *  @param value valor
 *  @return o HashMap criado. 
 */
private <K, V> Map<K, V> newHashMap(K key, V value) {
    Map<K, V> ret = new HashMap<K, V>();
    ret.put(key, value);
    return ret;
}
}